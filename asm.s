.data  #Инициализация модуля данных

# Ссылки на матрицы
A:   #Инициализация указателей на адрес,где хрантся массивы
    .quad 0      #адрес имеет размер =8 байт 
B:
    .quad 0
C:
    .quad 0

# Размерности матрицы
m:#Инициализация размерностей (указываем ссылку где лежат данные о размерностях матриц)
    .long 0    #Размерности  в С++ указаны были в integer - 4  байт
n:
    .long 0
l:
    .long 0


.text  #блок программ с командами (осоновная  часть программы)
    .globl mul_matrix #говорим,что при запуске программы  он начинал с метки 
    .type mul_matrix, @function  #указываем что mul_matrix-функция

# ЗАПОЛНЕНИЕ  итоговой  МАТРИЦЫ нулями - для простоты заполнения  итоговой матрицы после перемножения(*,+)
nul_matrix:
    # Высчитывание кол-во элементов в матрице
    movq $m, %rbx  #Помещаем ссылку размерности в регитср rbx  64 бит
    movl (%rbx), %eax #Переходим по адресу значения регистра rbx   и помещаем в регистр eax
    movq $l, %rcx
    movl (%rcx), %ebx #32
    mull %ebx  #Перемножение  количество элементов массивов регитсров ebx и  eax.Узнать количество элкментов в мат. С

    # Получить ссылку на матрицу С
    movq $C, %rcx  #укаазатель  на    первый элемент матрицы С,64 бит
    movq (%rcx), %rsi #Переходим по адресу значения регистра rcx и помещаем в регистр

    # 0, которым все заполним
    xorq %rcx, %rcx  #Исключающее ИЛИ.Если значения регистров одинаковы,то 0.

#Проход по каждому элементу матрицы и заполнение 0
loop_nul:
    
    movl %ecx, (%rsi) #Помещаем значение регистра в  адрес значения  регистра
    addq $4, %rsi   #Суммируем значение регистра-указатель наачло матрицы С и  размер размерностей матриц(4 байт).  Переходим на адрес следующего элемента для заполнения 0
    dec %eax  #Декремент -1 (счетчик количества элементов для заполнени я 0)
    cmpl $0, %eax  #Сравнение 0  с о значением регистра- колв-во элемен 
    jne loop_nul  #Если значения не эквиввленты , то переходим на метку

    ret

# ПЕРЕМНОЖЕНИЕ МАТРИЦ
mul_matrix:
    movq $A, %rax           # Сохранение матриц (Перемменная в которой будет храниться сссылка на матрицу)
    movq %rdi, (%rax)         #Указатель на 1 элмент матрицы А переносим в адрес значения регистра 
    movq $B, %rax
    movq %rsi, (%rax)
    movq $C, %rax
    movq %rdx, (%rax)

    movq $m, %rax           # Сохранение размерностей матриц
    movl %ecx, (%rax)          #Указатель размерности  1 элемента матрицы
    movq $n, %rax
    movl %r8d, (%rax) #32
    movq $l, %rax
    movl %r9d, (%rax)

    call nul_matrix        #Вызов процедуры- Заполнение матрицы С нулями


    movq $m, %rax
      movl (%rax), %ecx # Переменная i (от m-1 до 0) Перебор строк
      dec %ecx #Декремент -обращемся к  наибольшему индексу ма, изменяем индекс на 1.
              # Обработка ячеек матрицы - нет особо разницы в каком порядке обрабатывать ячейки
             # -в любом случае перемножаем элементы и +.
loop_i:

    push %rcx  #Помещаем в стэк

    movq $l, %rax   #Указаетль на размерность    
    movl (%rax), %ecx       # Переменная j (от l-1 до 0) Обращение к адресу значения регистра . Перебор столбцов
    dec %ecx               #Находим индекс  для обращения к элементу
loop_j:

    push %rcx

    movq $n, %rax  #Указатель на размерность матрицы
    movl (%rax), %ecx       # Переменная k (от n-1 до 0) n-максимальное  количество элементов ,а k-начальное значение
    dec %ecx
loop_k:
    pop %r8                 # Извлекаем из  стэка j
    pop %r9                 # i
    push %r9                #Помещаем в стэк
    push %r8

    movq $A, %rax           # r13 = Адрес + смещение для А  Для получения доступа к контркнетному элементу матрицы
    movq (%rax), %rsi
    movq %rcx, %rdx
    movq $n, %rax          #ширина матрицы
    movl (%rax), %ebx
    movq %r9, %rax     #Регитср строк
    push %rcx
    call calc  #Вызов процедуры
    pop %rcx
    movq %rsi, %r13

    movq $B, %rax           # r14 = Адрес + смещение для В   Для получения доступа к конкретному элементу матрицы
    movq (%rax), %rsi       
    movq %r8, %rdx          #регистр столбцов  
    movq $l, %rax          #кол-во стобцов 
    movl (%rax), %ebx
    movq %rcx, %rax
    push %rcx
    call calc          #Вызов процедуры
    pop %rcx
    movq %rsi, %r14

    movq $C, %rax           # r15 = Адрес + смещение для С
    movq (%rax), %rsi
    movq %r8, %rdx              #Регистр столбцоы
    movq $l, %rax                #колв-во стообцов
    movl (%rax), %ebx
    movq %r9, %rax              #регитср строк
    push %rcx
    call calc                     #Вызов процедуры
    pop %rcx
    movq %rsi, %r15

    movl (%r13), %eax       # Получить значение из А. Обраащеся к адресу значения регистра и помещаем  в регистр
    movl (%r14), %ebx       # Получить значение из В
    mull %ebx               # Перемножить  значения регистров ebx eax 
    movl (%r15), %edx       # Получить значение из С
    addl %edx, %eax         # Сложить его с перемноженным значением
    movl %eax, (%r15)       # Поместить обратно в С

    dec %ecx      #Декремент индекса матрицы
    cmpl $-1, %ecx  #Сравнение -1 и  значени индекса (от 0 до ...)
    jne loop_k      #Если не эквивалентны то переходим на метку, иначе продолжаем

    pop %rcx       #Извлекаем их стэка
    dec %ecx
    cmpl $-1, %ecx
    jne loop_j

    pop %rcx
    dec %ecx
    cmpl $-1, %ecx
    jne loop_i

    ret    # возврат из  процедуры (освобождение стека)

# ВЫСЧИТЫВАЕТ АДРЕС + СМЕЩЕНИЕ  для получения дсотупа к конкрентному элементу 
# eax - Стока элемента в матрице i
# ebx - Ширина матрицы n
# edx - Столбец матрицы j
# rsi - Адрес начала матрицы
# rsi = (eax * ebx + edx) * 4 + rsi   
calc:
    push %rcx 

    push %rdx  #Помещаем  в стек
    mull %ebx   #Произведение ебх и аех
    pop %rdx      
    addl %edx, %eax   #Cуммируем
    movl $4, %ebx   #Размерности в integer 
    mull %ebx
    addq %rax, %rsi   #Суммируем с адресом  матрицы.  Вычисляем адреса матрицы последней ячейки

    pop %rcx   #Извлекаем из стэка

    ret
